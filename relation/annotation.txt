관계설정 annotation
 1) @ManyToOne : 부서와 사원, 팀과 회원, 학과와 학생 관계 
               => 단일로 사용될땐 상하 관계를 표현할때 자주 사용됨.
               : 정보를 가지고 나올때 관련있는 테이블의 정보를 가지고 나옴(left join)
               : FetchType.EAGER 인 상태

 2) @OneToMany : 기본적으로는 정보를 가지고 나올때 세부정보를 가지고 나오지않음
               : FetchType.LAZY 인 상태

 3) @OneToOne  : 정보를 가지고 나올때 관련있는 테이블의 정보를 가지고 나옴(left join)
               : FetchType.EAGER 인 상태
               
 4) @ManyToMany : 실제 업무환경에서는 잘 사용되지않음
                  @ManyToOne 관계로 변경 후 사용 
                  FetchType.LAZY 인상태 

프록시(Proxy) : 프록시를 통해 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회하도록 함(지연로딩)
                자주 함께 사용하는 객체들은 조인을 통해서 함께 조회(즉시 로딩)
FetchType.LAZY : 지연 로딩
FetchType.EAGER : 즉시 로딩


양방향 관계는 없음 설명할땐 양방향이라고 하지만 실제로는 단방향 2개를 열어서 서로를 연결하는것
데이터베이스 테이블은 외래 키 하나로 양쪽이 서로 조인 가능 => 객체는 한쪽만 관계설정을 하면 안됨
단방향 2개를 여는 대신에 주인관계가 누구인지를 알려줘야함( @mappedBy )
장점 : 조회방법이 하나가 늘어남
       부서 조회시 부서에 속한 모든 사원 정보 조회

단점 : 

FetchType.LAZY 일 때 관련있는 테이블 정보를 접근한다면 
 LazyInitializationException 오류가 발생함
 세부정보를 가지고 나오지않았는데 사용또는 권한을 요청할때 오류가 생김
    => 해결 방안 
        1) @Transactional : SELECT 구문 2개로 처리함
        2) FetchType 변경 : "FetchType.EAGER"(즉시) 관계가 있는 테이블의
            정보를 즉시 출력 => SQL문에서 left join으로 처리한다. 


영속성 관리 
 : 양방향일때 사용할 수 있는 개념
 : 부모 저장 시 자식 엔티티도 같이 저장 

 @OneToMany(mappedBy = "parent", cascade = { CascadeType.PERSIST, CascadeType.REMOVE }, orphanRemoval = true)
 cascade = { CascadeType.PERSIST, CascadeType.REMOVE } : 상위 메소드 저장 및 삭제 시 하위 메소드도 같은 작업 수행 

 상위 객체에서 하위 객체를 제거하면 하위 객체가 제거 : orphanRemoval = true
